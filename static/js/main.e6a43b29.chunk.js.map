{"version":3,"sources":["features/balances/Balances.module.css","app/hooks.ts","features/orders/orderAPI.ts","features/transactions/transactionActions.ts","features/wallet/walletSlice.ts","features/orders/ordersSlice.ts","features/transactions/transactionsSlice.ts","features/metadata/metadataApi.ts","features/metadata/metadataSlice.ts","components/Card/Card.tsx","components/LoadingSpinner/LoadingSpinner.tsx","components/TokenSelect/TokenSelect.tsx","components/Timer/Timer.tsx","components/Button/Button.tsx","features/orders/Orders.tsx","features/balances/balancesApi.ts","components/WalletButton/WalletButton.tsx","constants/supportedWalletProviders.ts","assets/wallet-provider-logos/metamask.svg","assets/wallet-provider-logos/walletconnect.svg","components/WalletProviderList/WalletProviderList.tsx","features/balances/balancesSlice.ts","features/wallet/walletAPI.tsx","features/wallet/Wallet.tsx","features/transactions/Transactions.tsx","features/balances/Balances.tsx","i18n/i18n.ts","components/DarkModeSwitch/DarkModeSwitch.tsx","App.tsx","app/store.ts","features/metadata/metadataSubscriber.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","useAppDispatch","useDispatch","useAppSelector","useSelector","requestOrder","chainId","signerToken","senderToken","senderAmount","senderWallet","provider","a","Registry","getServers","servers","orderPromises","map","server","getSignerSideOrder","toAtomicString","order","Promise","allSettled","orders","successfulOrders","filter","result","status","value","approveToken","spender","Light","getAddress","network","ERC20","approve","getSigner","approvalTxHash","takeOrder","swap","tx","submitTransaction","createAction","declineTransaction","mineTransaction","revertTransaction","initialState","connected","address","walletSlice","createSlice","name","reducers","setWalletConnected","state","action","payload","setWalletDisconnected","actions","request","createAsyncThunk","params","dispatch","token","library","hash","transaction","type","tokenAddress","once","getTransactionReceipt","receipt","transactionHash","console","error","message","take","ordersSlice","clear","extraReducers","builder","addCase","pending","fulfilled","selectBestOrder","sort","b","signerAmount","parseInt","expiry","aAmount","BigNumber","from","lt","gt","selectOrdersStatus","updateTransaction","i","all","setTransactions","err","push","selectTransactions","transactions","defaultActiveTokens","chainIds","MAINNET","RINKEBY","getActiveTokensLocalStorageKey","account","getActiveTokensFromLocalStorage","savedTokens","localStorage","getItem","split","length","getTransactionsLocalStorageKey","walletAddress","fetchAllTokens","unused","thunkApi","getState","wallet","fetchTokens","metadataSlice","tokens","active","addActiveToken","lowerCasedToken","trim","toLowerCase","includes","removeActiveToken","tokenInfo","reduce","allTokens","rejected","selectActiveTokens","createSelector","metadata","activeTokenAddresses","allTokenInfo","Object","values","Card","children","className","classNames","LoadingSpinner","TokenSelect","withAmount","label","amount","onAmountChange","onTokenChange","t","useTranslation","onChange","placeholder","dir","symbol","Timer","expiryTime","Date","now","onTimerComplete","useState","Math","floor","distance","setDistance","useEffect","interval","setInterval","dist","clearInterval","undefined","colorClasses","neutral","primary","positive","destructive","variantClasses","centered","Button","intent","variant","disabled","loading","onClick","rest","variants","Array","isArray","e","v","Orders","ordersStatus","activeTokens","setSenderToken","setSignerToken","setSenderAmount","useWeb3React","trackEvent","useMatomo","toDecimalString","currentTarget","category","aria-label","context","tokenId","approvalTx","getTokenApprovalStatus","subscribeToTransfersAndApprovals","WalletButton","isConnecting","onConnectWalletClicked","onDisconnectWalletClicked","size","scale","seed","bgColor","color","truncateEthAddress","SUPPORTED_WALLET_PROVIDERS","logo","getConnector","InjectedConnector","supportedChainIds","WalletConnectConnector","rpc","1","4","WalletProviderList","onProviderSelected","src","alt","balancesInterface","ethers","utils","Interface","JSON","stringify","BalanceChecker","abi","erc20Interface","erc20Abi","getContract","Contract","balancesDeploys","fetchBalancesOrAllowances","method","tokenAddresses","contract","args","apply","amounts","toString","fetchBalances","bind","fetchAllowances","onBalanceChange","spenderAddress","onApproval","filters","out","topics","id","hexZeroPad","in","tearDowns","keys","forEach","direction","typedDirection","listener","event","lowerCasedAddress","parsedEvent","parseLog","isApproval","on","off","fn","lastFetch","inFlightFetchTokens","getSetInFlightRequestTokensAction","getThunk","methods","balances","allowances","activeTokensAddresses","condition","sliceState","getSlice","asyncThunk","incrementBy","currentAmount","add","decrementBy","newAmount","sub","set","tokenBalances","every","selectBalances","selectAllowances","requestActiveTokenBalances","requestActiveTokenAllowances","balancesSlice","allowancesSlice","incrementBalanceBy","decrementBalanceBy","setAllowance","balancesReducer","reducer","allowancesReducer","LAST_ACCOUNT_LOCAL_STORAGE_KEY","Wallet","activate","deactivate","trackPageView","showConnectorList","setShowConnectorList","isActivating","setIsActivating","connector","setConnector","setProvider","documentTitle","href","lastConnectedAccount","storedString","Error","providerName","find","p","loadLastAccount","finally","setItem","saveLastAccount","teardownTransferListener","isOpen","onRequestClose","overlayClassName","close","Transactions","walletHasChanged","transactionsLocalStorage","parse","reason","getTransaction","wait","assumedFailureTime","res","setTimeout","icons","succeeded","reverted","processing","submittedOrder","target","rel","getEtherscanURL","Balances","addTokenField","setAddTokenField","classes","balancesGrid","bold","tokenBalance","tokenAllowance","formatUnits","decimals","i18n","use","HttpBackend","LanguageDetector","initReactI18next","init","fallbackLng","ns","load","debug","process","interpolation","escapeValue","react","useSuspense","backend","loadPath","enableDarkMode","document","documentElement","classList","THEME_LOCAL_STORAGE_KEY","disableDarkMode","remove","window","matchMedia","matches","DarkModeSwitch","darkModeEnabled","setDarkModeEnabled","toggle","getLibrary","Web3Provider","pollingInterval","App","fallback","store","configureStore","transactionsReducer","metadataReducer","ordersReducer","walletReducer","currentTransaction","activeTokensCache","transactionCache","subscribe","txs","cachedTokensForActiveWallet","join","subscribeToSavedTokenChangesForLocalStoragePersisting","Boolean","location","hostname","match","instance","createInstance","urlBase","siteId","srcUrl","heartBeat","seconds","linkTracking","configurations","disableCookies","setSecureCookie","setRequestMethod","Modal","setAppElement","ReactDOM","render","StrictMode","MatomoProvider","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.e6a43b29.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"balancesGrid\":\"Balances_balancesGrid__1j9mL\",\"bold\":\"Balances_bold__38IeB\"};","import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\nimport type { RootState, AppDispatch } from \"./store\";\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { ethers, Transaction } from \"ethers\";\nimport { Registry, Light, ERC20 } from \"@airswap/protocols\";\nimport { LightOrder } from \"@airswap/types\";\nimport { toAtomicString } from \"@airswap/utils\";\n\nexport async function requestOrder(\n  chainId: number,\n  signerToken: string,\n  senderToken: string,\n  senderAmount: string,\n  senderWallet: string,\n  provider: ethers.providers.Web3Provider\n): Promise<LightOrder[]> {\n  const servers = await new Registry(chainId, provider).getServers(\n    signerToken,\n    senderToken\n  );\n  const orderPromises = servers.map(async (server) => {\n    const order = await server.getSignerSideOrder(\n      toAtomicString(senderAmount, 18),\n      signerToken,\n      senderToken,\n      senderWallet\n    );\n    return order as any as LightOrder;\n  });\n  const orders = await Promise.allSettled(orderPromises);\n  const successfulOrders = orders\n    .filter((result) => result.status === \"fulfilled\")\n    .map((result) => (result as PromiseFulfilledResult<LightOrder>).value);\n  return successfulOrders;\n}\n\nexport async function approveToken(\n  senderToken: string,\n  provider: ethers.providers.Web3Provider\n) {\n  const spender = Light.getAddress(provider.network.chainId);\n  const approvalTxHash = await new ERC20(senderToken).approve(\n    spender,\n    provider.getSigner()\n  );\n  return approvalTxHash as any as Transaction;\n}\n\nexport async function takeOrder(\n  order: LightOrder,\n  provider: ethers.providers.Web3Provider\n) {\n  const tx = await new Light(provider.network.chainId, provider).swap(\n    order,\n    provider.getSigner()\n  );\n  return tx as any as Transaction;\n}\n","import { createAction } from \"@reduxjs/toolkit\";\nimport { SubmittedTransaction } from './transactionsSlice'\n\nconst submitTransaction = createAction<SubmittedTransaction>(\"transaction/submitTransaction\");\n\nconst declineTransaction = createAction<{\n  hash: string;\n  reason: string;\n}>(\"transactions/declineTransaction\");\n\nconst mineTransaction = createAction<string>(\"transaction/mineTransaction\");\n\nconst revertTransaction = createAction<{\n  hash: string;\n  reason: string;\n}>(\"transactions/revertTransaction\");\n\nexport {\n  submitTransaction,\n  declineTransaction,\n  mineTransaction,\n  revertTransaction,\n};\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\n\nexport interface WalletState {\n  connected: boolean;\n  address: string | null;\n  chainId: number | null;\n}\n\nconst initialState: WalletState = {\n  connected: false,\n  address: null,\n  chainId: null,\n};\n\nconst walletSlice = createSlice({\n  name: \"wallet\",\n  initialState,\n  reducers: {\n    setWalletConnected: (\n      state,\n      action: PayloadAction<{ address: string; chainId: number }>\n    ) => {\n      state.connected = true;\n      state.address = action.payload.address;\n      state.chainId = action.payload.chainId;\n    },\n    setWalletDisconnected: () => initialState,\n  },\n});\n\nexport const selectWallet = (state: RootState) => state.wallet;\n\nexport const { setWalletConnected, setWalletDisconnected } =\n  walletSlice.actions;\n\nexport default walletSlice.reducer;\n","import { LightOrder } from \"@airswap/types\";\nimport { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport { requestOrder, takeOrder, approveToken } from \"./orderAPI\";\nimport {\n  submitTransaction,\n  mineTransaction,\n  revertTransaction,\n  declineTransaction,\n} from \"../transactions/transactionActions\";\nimport {\n  setWalletConnected,\n  setWalletDisconnected,\n} from \"../wallet/walletSlice\";\nimport {\n  SubmittedOrder,\n  SubmittedApproval,\n} from \"../transactions/transactionsSlice\";\nimport { BigNumber, Transaction } from \"ethers\";\n\nexport interface OrdersState {\n  orders: LightOrder[];\n  status: \"idle\" | \"requesting\" | \"taking\" | \"failed\";\n}\n\nconst initialState: OrdersState = {\n  orders: [],\n  status: \"idle\",\n};\n\nexport const request = createAsyncThunk(\n  \"orders/request\",\n  async (params: {\n    chainId: number;\n    signerToken: string;\n    senderToken: string;\n    senderAmount: string;\n    senderWallet: string;\n    provider: any;\n  }) =>\n    await requestOrder(\n      params.chainId,\n      params.signerToken,\n      params.senderToken,\n      params.senderAmount,\n      params.senderWallet,\n      params.provider\n    )\n);\n\nexport const approve = createAsyncThunk(\n  \"orders/approve\",\n  async (params: any, { dispatch }) => {\n    let tx: Transaction;\n    try {\n      tx = await approveToken(params.token, params.library);\n      if (tx.hash) {\n        const transaction: SubmittedApproval = {\n          type: \"Approval\",\n          hash: tx.hash,\n          status: \"processing\",\n          tokenAddress: params.token,\n        };\n        dispatch(submitTransaction(transaction));\n        params.library.once(tx.hash, async () => {\n          const receipt = await params.library.getTransactionReceipt(tx.hash);\n          if (receipt.status === 1) {\n            dispatch(mineTransaction(receipt.transactionHash));\n          } else {\n            dispatch(revertTransaction(receipt.transactionHash));\n          }\n        });\n      }\n    } catch (e) {\n      console.error(e);\n      dispatch(declineTransaction(e.message));\n    }\n  }\n);\n\nexport const take = createAsyncThunk(\n  \"orders/take\",\n  async (params: any, { dispatch }) => {\n    let tx: Transaction;\n    try {\n      tx = await takeOrder(params.order, params.library);\n      if (tx.hash) {\n        const transaction: SubmittedOrder = {\n          type: \"Order\",\n          order: params.order,\n          hash: tx.hash,\n          status: \"processing\",\n        };\n        dispatch(submitTransaction(transaction));\n        params.library.once(tx.hash, async () => {\n          const receipt = await params.library.getTransactionReceipt(tx.hash);\n          if (receipt.status === 1) {\n            dispatch(mineTransaction(receipt.transactionHash));\n          } else {\n            dispatch(revertTransaction(receipt.transactionHash));\n          }\n        });\n      }\n    } catch (e) {\n      console.error(e);\n      dispatch(declineTransaction(e.message));\n    }\n  }\n);\n\nexport const ordersSlice = createSlice({\n  name: \"orders\",\n  initialState,\n  reducers: {\n    clear: (state) => {\n      state.orders = [];\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(request.pending, (state) => {\n        state.status = \"requesting\";\n      })\n      .addCase(request.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        state.orders = action.payload!;\n      })\n      .addCase(take.pending, (state) => {\n        state.status = \"taking\";\n      })\n      .addCase(take.fulfilled, (state, action) => {\n        state.status = \"idle\";\n      })\n      .addCase(setWalletConnected, (state) => {\n        state.status = \"idle\";\n        state.orders = [];\n      })\n      .addCase(setWalletDisconnected, (state) => {\n        state.status = \"idle\";\n        state.orders = [];\n      });\n  },\n});\n\nexport const { clear } = ordersSlice.actions;\n/**\n * Sorts orders and returns the best order based on tokens received or sent\n * then falling back to expiry.\n */\nexport const selectBestOrder = (state: RootState) =>\n  state.orders.orders.sort((a, b) => {\n    // If tokens transferred are the same\n    if (\n      a.signerAmount === b.signerAmount &&\n      a.senderAmount === b.senderAmount\n    ) {\n      return parseInt(b.expiry) - parseInt(a.expiry);\n    }\n    if (a.signerAmount === b.signerAmount) {\n      // Likely senderSide\n      // Sort orders by amount of senderToken sent (ascending).\n      const aAmount = BigNumber.from(a.senderAmount);\n      const bAmount = BigNumber.from(b.senderAmount);\n      if (bAmount.lt(aAmount)) return 1;\n      else return -1;\n    } else {\n      // Likely signerSide\n      // Sort orders by amount of signerToken received (descending).\n      const aAmount = BigNumber.from(a.signerAmount);\n      const bAmount = BigNumber.from(b.signerAmount);\n      if (bAmount.gt(aAmount)) return 1;\n      else return -1;\n    }\n  })[0];\nexport const selectOrdersStatus = (state: RootState) => state.orders.status;\nexport default ordersSlice.reducer;\n","import { LightOrder } from \"@airswap/types\";\nimport { createSlice } from \"@reduxjs/toolkit\";\nimport { RootState } from \"../../app/store\";\nimport {\n  submitTransaction,\n  declineTransaction,\n  revertTransaction,\n  mineTransaction,\n} from \"./transactionActions\";\n\nexport interface SubmittedTransaction {\n  type: \"Approval\" | \"Order\";\n  hash: string;\n  status: \"processing\" | \"succeeded\" | \"reverted\";\n}\n\nexport interface SubmittedOrder extends SubmittedTransaction {\n  order: LightOrder;\n}\n\nexport interface SubmittedApproval extends SubmittedTransaction {\n  tokenAddress: string;\n}\n\nexport interface TransactionsState {\n  all: SubmittedTransaction[];\n}\n\nconst initialState: TransactionsState = {\n  all: [],\n};\n\nfunction updateTransaction(\n  state: TransactionsState,\n  hash: string,\n  status: \"processing\" | \"succeeded\" | \"reverted\"\n) {\n  for (let i in state.all) {\n    if (state.all[i].hash === hash) {\n      state.all[i] = {\n        ...state.all[i],\n        status,\n      };\n      break;\n    }\n  }\n}\n\nexport const ordersSlice = createSlice({\n  name: \"transactions\",\n  initialState,\n  reducers: {\n    clear: (state) => {\n      state.all = [];\n    },\n    setTransactions: (state, action) => {\n      try {\n        state.all = action.payload.all;\n      } catch (err) {\n        console.error(err);\n        state.all = [];\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(submitTransaction, (state, action) => {\n      state.all.push(action.payload);\n    });\n    builder.addCase(declineTransaction, (state, action) => {\n      console.error(action.payload);\n    });\n    builder.addCase(revertTransaction, (state, action) => {\n      updateTransaction(state, action.payload.hash, \"reverted\");\n    });\n    builder.addCase(mineTransaction, (state, action) => {\n      updateTransaction(state, action.payload, \"succeeded\");\n    });\n  },\n});\n\nexport const { clear, setTransactions } = ordersSlice.actions;\nexport const selectTransactions = (state: RootState) => state.transactions.all;\nexport default ordersSlice.reducer;\n","import { chainIds } from \"@airswap/constants\";\nimport { fetchTokens } from \"@airswap/metadata\";\nimport { TokenInfo } from \"@uniswap/token-lists\";\nimport uniqBy from \"lodash.uniqby\";\n\nexport const defaultActiveTokens: {\n  [chainId: number]: string[];\n} = {\n  [chainIds.MAINNET]: [\n    \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\", // WETH\n    \"0xdac17f958d2ee523a2206206994597c13d831ec7\", // USDT\n    \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\", // USDC\n    \"0x6b175474e89094c44da98b954eedeac495271d0f\", // DAI\n    \"0x27054b13b1b798b345b591a4d22e6562d47ea75a\", // AST\n  ],\n  [chainIds.RINKEBY]: [\n    \"0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\", // DAI\n    \"0xc778417e063141139fce010982780140aa0cd5ab\", // WETH\n  ],\n};\n\nconst tokensCache: {\n  [chainId: number]: Promise<TokenInfo[]>;\n} = {};\n\nexport const getActiveTokensLocalStorageKey: (\n  account: string,\n  chainId: number\n) => string = (account, chainId) =>\n  `airswap/activeTokens/${account}/${chainId}`;\n\nexport const getAllTokens = async (chainId: number) => {\n  let tokens;\n  if (!tokensCache[chainId]) {\n    tokensCache[chainId] = fetchTokens(chainId);\n  }\n  // TODO: handle failure.\n  tokens = await tokensCache[chainId];\n  return tokens;\n};\n\nexport const getActiveTokensFromLocalStorage = (\n  account: string,\n  chainId: number\n) => {\n  const savedTokens = (\n    localStorage.getItem(getActiveTokensLocalStorageKey(account, chainId)) || \"\"\n  )\n    .split(\",\")\n    .filter((address) => address.length);\n  return (\n    (savedTokens.length && savedTokens) || defaultActiveTokens[chainId] || []\n  );\n};\n\nexport const getSavedActiveTokensInfo = async (\n  account: string,\n  chainId: number\n) => {\n  const tokens = await getAllTokens(chainId);\n  const activeTokens = getActiveTokensFromLocalStorage(account, chainId);\n  const matchingTokens = tokens.filter((tokenInfo) =>\n    activeTokens.includes(tokenInfo.address)\n  );\n  return uniqBy(matchingTokens, (token) => token.address);\n};\n\nexport const getTransactionsLocalStorageKey: (\n  walletAddress: string,\n  chainId: number\n) => string = (walletAddress, chainId) =>\n  `airswap/transactions/${walletAddress}/${chainId}`;\n","import { fetchTokens } from \"@airswap/metadata\";\nimport {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from \"@reduxjs/toolkit\";\nimport { TokenInfo } from \"@uniswap/token-lists\";\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport {\n  setWalletConnected,\n  setWalletDisconnected,\n} from \"../wallet/walletSlice\";\nimport {\n  defaultActiveTokens,\n  getActiveTokensFromLocalStorage,\n} from \"./metadataApi\";\n\nexport interface MetadataState {\n  tokens: {\n    all: {\n      [address: string]: TokenInfo;\n    };\n    active: string[];\n  };\n}\n\nconst initialState: MetadataState = {\n  tokens: {\n    all: {},\n    active: [],\n  },\n};\n\nexport const fetchAllTokens = createAsyncThunk<\n  TokenInfo[],\n  void,\n  {\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"metadata/fetchTokens\", async (unused, thunkApi) => {\n  const { wallet } = thunkApi.getState();\n  if (!wallet.connected) return [];\n  return await fetchTokens(wallet.chainId!);\n});\n\nexport const metadataSlice = createSlice({\n  name: \"metadata\",\n  initialState,\n  reducers: {\n    addActiveToken: (state, action: PayloadAction<string>) => {\n      const lowerCasedToken = action.payload.trim().toLowerCase();\n      if (!state.tokens.active.includes(lowerCasedToken)) {\n        state.tokens.active.push(lowerCasedToken);\n      }\n    },\n    removeActiveToken: (state, action: PayloadAction<string>) => {\n      if (state.tokens.active.includes(action.payload)) {\n        state.tokens.active = state.tokens.active.filter(\n          (tokenAddress) => tokenAddress !== action.payload\n        );\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchAllTokens.pending, (state) => {\n        // TODO: consider whether we need to put a pending state to prevent dupes\n      })\n      .addCase(fetchAllTokens.fulfilled, (state, action) => {\n        const { payload: tokenInfo } = action;\n        state.tokens.all = tokenInfo.reduce(\n          (allTokens: { [address: string]: TokenInfo }, token) => {\n            const { address } = token;\n            if (!allTokens[address]) {\n              allTokens[address] = token;\n            }\n            return allTokens;\n          },\n          {}\n        );\n      })\n      .addCase(fetchAllTokens.rejected, (state) => {\n        // TODO: handle failure?\n      })\n      .addCase(setWalletConnected, (state, action) => {\n        const { chainId, address } = action.payload;\n        state.tokens.active =\n          getActiveTokensFromLocalStorage(address, chainId) ||\n          defaultActiveTokens[chainId] ||\n          [];\n      })\n      .addCase(setWalletDisconnected, (state) => {\n        state.tokens.active = [];\n      });\n  },\n});\n\nexport const { addActiveToken } = metadataSlice.actions;\n\nconst selectActiveTokenAddresses = (state: RootState) =>\n  state.metadata.tokens.active;\nconst selectAllTokenInfo = (state: RootState) => state.metadata.tokens.all;\nexport const selectActiveTokens = createSelector(\n  [selectActiveTokenAddresses, selectAllTokenInfo],\n  (activeTokenAddresses, allTokenInfo) => {\n    return Object.values(allTokenInfo).filter((tokenInfo) =>\n      activeTokenAddresses.includes(tokenInfo.address)\n    );\n  }\n);\n\nexport default metadataSlice.reducer;\n","import classNames from \"classnames\";\n\nconst Card = ({\n  children,\n  className,\n}: {\n  children: React.ReactNode;\n  className?: string;\n}) => {\n  return (\n    <div className={classNames(\"p-4 flex bg-white dark:bg-black\", className)}>\n      {children}\n    </div>\n  );\n};\n\nexport default Card;\n","import classNames from \"classnames\";\nimport { AiOutlineLoading } from \"react-icons/ai\";\n\ntype LoadingSpinnerProps = { className?: string };\n\nconst LoadingSpinner = ({ className }: LoadingSpinnerProps) => {\n  return (\n    <div\n      className={classNames(\n        \"flex items-center justify-center h-full w-full\",\n        className\n      )}\n    >\n      <AiOutlineLoading className=\"animate-spin\" />\n    </div>\n  );\n};\n\nexport default LoadingSpinner;\n","import classNames from \"classnames\";\nimport { TokenInfo } from \"@uniswap/token-lists\";\nimport { HiOutlineChevronRight } from \"react-icons/hi\";\nimport { useTranslation } from \"react-i18next\";\nimport LoadingSpinner from \"../LoadingSpinner/LoadingSpinner\";\n\ntype TokenSelectPropTypes = {\n  withAmount: boolean;\n  label: string;\n  className?: string;\n  amount?: string;\n  token?: string;\n  tokens: TokenInfo[];\n  onAmountChange?: React.FormEventHandler<HTMLInputElement>;\n  onTokenChange?: React.FormEventHandler<HTMLSelectElement>;\n};\n\nconst TokenSelect = ({\n  withAmount,\n  label,\n  className,\n  tokens,\n  amount,\n  onAmountChange,\n  token,\n  onTokenChange,\n}: TokenSelectPropTypes) => {\n  const { t } = useTranslation([\"common\", \"orders\"]);\n\n  return (\n    <div className={classNames(\"flex flex-col\", className)}>\n      <div className=\"font-bold text-sm\">{label}</div>\n      <div\n        className={classNames(\n          \"flex justify-between pb-1 items-center\",\n          \"border-b border-black border-opacity-20\",\n          \"dark:border-white  dark:border-opacity-20\"\n        )}\n      >\n        {/* Amount input */}\n        {withAmount ? (\n          <input\n            type=\"text\"\n            className={classNames(\n              \"bg-transparent border-0 px-0 py-0\",\n              \"placeholder-gray-500 text-sm\",\n              \"dark:text-white\"\n            )}\n            value={amount}\n            onChange={onAmountChange}\n            placeholder=\"0\"\n          ></input>\n        ) : (\n          <span className=\"text-gray-500 text-sm\">\n            {!token ? t(\"orders:chooseToken\") : \"\"}\n          </span>\n        )}\n\n        {/* Token Selector */}\n        <div className=\"flex font-bold items-center\">\n          {tokens ? (\n            <select\n              dir=\"rtl\"\n              className={classNames(\n                \"-mr-6 pr-6 border-0 bg-transparent appearance-none\",\n                \"text-sm\",\n                \"dark:text-white\",\n                {\n                  \"text-gray-500\": !token,\n                }\n              )}\n              value={token}\n              onChange={onTokenChange}\n            >\n              <option>…{t(\"common:select\")}</option>\n              {tokens.map((token) => (\n                <option key={token.address} value={token.address}>\n                  {token.symbol}\n                </option>\n              ))}\n            </select>\n          ) : (\n            <LoadingSpinner className=\"mx-2\" />\n          )}\n          <HiOutlineChevronRight className=\"text-primary text-xl pointer-events-none\" />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TokenSelect;\n","import { useState, useEffect } from \"react\";\n\nexport type TimerProps = {\n  className?: string;\n  /**\n   * Expiration time in unix timestamp (s)\n   */\n  expiryTime: number;\n  onTimerComplete: () => void;\n};\n\nexport const Timer = ({\n  expiryTime = Date.now() / 1000 + 300,\n  onTimerComplete,\n}: TimerProps) => {\n  const [distance, setDistance] = useState<number>(Math.floor(expiryTime - Date.now() / 1000));\n\n  useEffect(() => {\n    let interval = setInterval(() => {\n      const dist: number = Math.floor(expiryTime - Date.now() / 1000);\n\n      if (dist <= 0) {\n        setDistance(0);\n        clearInterval(interval);\n        onTimerComplete();\n        return;\n      }\n\n      setDistance(dist);\n    }, 1000);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [expiryTime, onTimerComplete]);\n\n  return distance !== undefined ? (\n    <span>\n      {Math.floor(distance / 60)}:\n      {Math.floor(distance % 60) < 10\n        ? `0${Math.floor(distance % 60)}`\n        : Math.floor(distance % 60)}\n    </span>\n  ) : null;\n};\n\nexport default Timer;\n","import classNames from \"classnames\";\nimport LoadingSpinner from \"../LoadingSpinner/LoadingSpinner\";\n\ntype ButtonIntent = \"neutral\" | \"primary\" | \"positive\" | \"destructive\";\ntype ButtonVariant = \"centered\" | \"left-justified\";\n\nexport type ButtonProps = {\n  children: React.ReactNode;\n  className?: string;\n  /**\n   * Intent affects the appearance of the button\n   */\n  intent?: ButtonIntent;\n  /**\n   * Intent affects the appearance of the button\n   */\n  variant?: ButtonVariant | ButtonVariant[];\n  /**\n   * Whether or not the button should be disabled. Clicking a disabled button\n   * has no effect.\n   */\n  disabled?: boolean;\n  /**\n   * Whether or not to show a loading spinner within the button. This also\n   * prevents further clicks on the button\n   */\n  loading?: boolean;\n} & React.DetailedHTMLProps<\n  React.ButtonHTMLAttributes<HTMLButtonElement>,\n  HTMLButtonElement\n>;\n\nconst colorClasses: Record<ButtonIntent, string> = {\n  neutral: \"bg-gray-200 text-black dark:bg-gray-700 dark:text-white\",\n  primary: \"bg-primary text-white\",\n  positive: \"bg-green-700 text-white\",\n  destructive: \"bg-red-700 text-white\",\n};\n\nconst variantClasses: Record<ButtonVariant, string> = {\n  centered: \"justify-center\",\n  \"left-justified\": \"justify-start\",\n};\n\nexport const Button = ({\n  children,\n  className = \"\",\n  intent = \"neutral\",\n  variant = \"centered\",\n  disabled = false,\n  loading = false,\n  onClick,\n  ...rest\n}: ButtonProps) => {\n  const variants = Array.isArray(variant) ? variant : [variant];\n  return (\n    <button\n      className={classNames(\n        \"px-2 py-1 rounded-sm\",\n        colorClasses[intent],\n        className,\n        {\n          \"opacity-50\": disabled,\n          \"pointer-events-none\": disabled || loading,\n          \"cursor-wait\": loading,\n        }\n      )}\n      onClick={(e) => {\n        !loading && onClick && onClick(e);\n      }}\n      {...rest}\n    >\n      {/* // Note we keep children in here so the button doesn't change shape when\n        // it's loading. */}\n      <div\n        className={classNames(\n          \"flex flex-row items-center\",\n          variants.map((v) => variantClasses[v])\n        )}\n      >\n        <div\n          className={classNames(\"transition-opacity\", {\n            \"opacity-20\": loading,\n            \"opacity-100\": !loading,\n          })}\n        >\n          {children}\n        </div>\n        {loading && <LoadingSpinner className=\"absolute\" />}\n      </div>\n    </button>\n  );\n};\n\nexport default Button;\n","import { useState } from \"react\";\nimport { toDecimalString } from \"@airswap/utils\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport { useAppSelector, useAppDispatch } from \"../../app/hooks\";\nimport {\n  approve,\n  request,\n  take,\n  selectBestOrder,\n  selectOrdersStatus,\n} from \"./ordersSlice\";\nimport {\n  SubmittedApproval,\n  selectTransactions,\n} from \"../transactions/transactionsSlice\";\nimport { selectActiveTokens } from \"../metadata/metadataSlice\";\nimport { useTranslation } from \"react-i18next\";\nimport { useMatomo } from \"@datapunt/matomo-tracker-react\";\nimport Card from \"../../components/Card/Card\";\nimport TokenSelect from \"../../components/TokenSelect/TokenSelect\";\nimport Timer from \"../../components/Timer/Timer\";\nimport Button from \"../../components/Button/Button\";\n\nexport function Orders() {\n  const order = useAppSelector(selectBestOrder);\n  const ordersStatus = useAppSelector(selectOrdersStatus);\n  const transactions = useAppSelector(selectTransactions);\n  const dispatch = useAppDispatch();\n  const activeTokens = useAppSelector(selectActiveTokens);\n  const [senderToken, setSenderToken] = useState<string>();\n  const [signerToken, setSignerToken] = useState<string>();\n  const [senderAmount, setSenderAmount] = useState(\"0.01\");\n  const { chainId, account, library, active } = useWeb3React<Web3Provider>();\n  const { t } = useTranslation([\"orders\", \"common\"]);\n  const { trackEvent } = useMatomo();\n\n  let signerAmount = null;\n  if (order) {\n    signerAmount = toDecimalString(order.signerAmount, 6);\n  }\n\n  const getTokenApprovalStatus = (tokenId: string | undefined) => {\n    if (tokenId === undefined) return null;\n    for (let i = 0; i < transactions.length; i++) {\n      if (transactions[i].type === \"Approval\") {\n        const approvalTx: SubmittedApproval = transactions[\n          i\n        ] as SubmittedApproval;\n        if (approvalTx.tokenAddress === tokenId) return approvalTx.status;\n      }\n    }\n    return null;\n  };\n\n  if (!active || !chainId) return null;\n\n  return (\n    <Card className=\"flex-col m-4 w-72\">\n      <TokenSelect\n        tokens={activeTokens}\n        withAmount={true}\n        amount={senderAmount}\n        onAmountChange={(e) => setSenderAmount(e.currentTarget.value)}\n        className=\"mb-2\"\n        label={t(\"orders:send\")}\n        token={senderToken}\n        onTokenChange={(e) => setSenderToken(e.currentTarget.value)}\n      />\n      <TokenSelect\n        tokens={activeTokens}\n        withAmount={false}\n        className=\"mb-2\"\n        label=\"Receive\"\n        token={signerToken}\n        onTokenChange={(e) => setSignerToken(e.currentTarget.value)}\n      />\n      <Button\n        className=\"w-full mt-2\"\n        intent=\"primary\"\n        disabled={!senderToken || !signerToken || !senderAmount}\n        loading={ordersStatus === \"requesting\"}\n        onClick={() => {\n          dispatch(\n            request({\n              chainId: chainId!,\n              senderToken: senderToken!,\n              senderAmount,\n              signerToken: signerToken!,\n              senderWallet: account!,\n              provider: library,\n            })\n          );\n          trackEvent({ category: \"order\", action: \"request\" });\n        }}\n      >\n        {t(\"orders:request\")}\n      </Button>\n      {signerAmount ? (\n        <div>\n          {order ? (\n            <>\n              <div>Amount to receive: {signerAmount}</div>\n              <p>\n                Quote expires in&nbsp;\n                <Timer\n                  expiryTime={parseInt(order.expiry)}\n                  onTimerComplete={() => {\n                    dispatch(\n                      request({\n                        chainId: chainId!,\n                        senderToken: senderToken!,\n                        senderAmount,\n                        signerToken: signerToken!,\n                        senderWallet: account!,\n                        provider: library,\n                      })\n                    );\n                    trackEvent({ category: \"order\", action: \"request\" });\n                  }}\n                />\n              </p>\n            </>\n          ) : null}\n          <div className=\"flex gap-2\">\n            <Button\n              className=\"flex-1\"\n              aria-label={t(\"orders:approve\", { context: \"aria\" })}\n              loading={getTokenApprovalStatus(senderToken) === \"processing\"}\n              onClick={() => dispatch(approve({ token: senderToken, library }))}\n            >\n              {t(\"orders:approve\")}\n            </Button>\n            <Button\n              className=\"flex-1\"\n              aria-label={t(\"orders:take\", { context: \"aria\" })}\n              loading={ordersStatus === \"taking\"}\n              onClick={async () => dispatch(take({ order, library }))}\n            >\n              {t(\"orders:take\")}\n            </Button>\n          </div>\n        </div>\n      ) : (\n        <span />\n      )}\n    </Card>\n  );\n}\n","import { BigNumber, ethers, EventFilter, Event } from \"ethers\";\n\nimport BalanceChecker from \"@airswap/balances/build/contracts/BalanceChecker.json\";\nimport balancesDeploys from \"@airswap/balances/deploys.js\";\nimport { Light } from \"@airswap/protocols\";\nimport erc20Abi from \"erc-20-abi\";\nimport { hexZeroPad, id } from \"ethers/lib/utils\";\n\ninterface SubscribeParams {\n  activeTokenAddresses: string[];\n  walletAddress: string;\n  spenderAddress: string;\n  provider: ethers.providers.Web3Provider;\n  onBalanceChange: (\n    tokenAddress: string,\n    amount: BigNumber,\n    direction: \"in\" | \"out\"\n  ) => void;\n  onApproval: (tokenAddress: string, amount: BigNumber) => void;\n}\n\ninterface WalletParams {\n  chainId: number;\n  provider: ethers.providers.Web3Provider;\n  walletAddress: string;\n  tokenAddresses: string[];\n}\n\nconst balancesInterface = new ethers.utils.Interface(\n  JSON.stringify(BalanceChecker.abi)\n);\n\nconst erc20Interface = new ethers.utils.Interface(erc20Abi);\n\nconst getContract = (\n  chainId: keyof typeof balancesDeploys,\n  provider: ethers.providers.Web3Provider\n) => {\n  return new ethers.Contract(\n    balancesDeploys[chainId],\n    balancesInterface,\n    provider\n  );\n};\n\n/**\n * Fetches balances or allowances for a wallet using the airswap utility\n * contract `BalanceChecker.sol`. Balances are returned in base units.\n */\nconst fetchBalancesOrAllowances: (\n  method: \"walletBalances\" | \"walletAllowances\",\n  params: WalletParams\n) => Promise<string[]> = async (\n  method,\n  { chainId, provider, tokenAddresses, walletAddress }\n) => {\n  const contract = getContract(chainId, provider);\n  const args =\n    method === \"walletBalances\"\n      ? [walletAddress, tokenAddresses]\n      : // sender, spender, tokens.\n        [walletAddress, Light.getAddress(chainId), tokenAddresses];\n  const amounts: BigNumber[] = await contract[method].apply(null, args);\n  return amounts.map((amount) => amount.toString());\n};\n\nconst fetchBalances = fetchBalancesOrAllowances.bind(null, \"walletBalances\");\nconst fetchAllowances = fetchBalancesOrAllowances.bind(\n  null,\n  \"walletAllowances\"\n);\n\n// event Transfer(address indexed _from, address indexed _to, uint256 _value)\n// event Approval(address indexed _owner, address indexed _spender, uint256 _value)\nlet subscribeToTransfersAndApprovals: (params: SubscribeParams) => () => void;\nsubscribeToTransfersAndApprovals = ({\n  activeTokenAddresses,\n  walletAddress,\n  provider,\n  onBalanceChange,\n  spenderAddress,\n  onApproval,\n}) => {\n  // event Transfer(address indexed _from, address indexed _to, uint256 _value)\n  const filters: {\n    in: EventFilter;\n    out: EventFilter;\n  } = {\n    // Tokens being transferred out of our account or approved by our account\n    out: {\n      topics: [\n        [\n          id(\"Transfer(address,address,uint256)\"),\n          id(\"Approval(address,address,uint256)\"),\n        ], // event name\n        hexZeroPad(walletAddress, 32), // from\n      ],\n    },\n\n    // Tokens being transferred in to our account\n    in: {\n      topics: [\n        id(\"Transfer(address,address,uint256)\"), // event name\n        [],\n        hexZeroPad(walletAddress, 32), // to\n      ],\n    },\n  };\n\n  const tearDowns: (() => void)[] = [];\n\n  Object.keys(filters).forEach((direction) => {\n    // in or out?\n    const typedDirection = direction as keyof typeof filters;\n    const filter = filters[typedDirection];\n\n    function listener(event: Event) {\n      const { address } = event;\n      const lowerCasedAddress = address.toLowerCase();\n\n      // Ignore transactions for non-active tokens.\n      if (!activeTokenAddresses.includes(lowerCasedAddress)) return;\n\n      const parsedEvent = erc20Interface.parseLog(event);\n      const isApproval = parsedEvent.name === \"Approval\";\n\n      // Ignore approvals for other spenders.\n      if (isApproval && parsedEvent.args[1].toLowerCase() !== spenderAddress)\n        return;\n\n      const amount: BigNumber = parsedEvent.args[2];\n      isApproval\n        ? onApproval(lowerCasedAddress, amount)\n        : onBalanceChange(lowerCasedAddress, amount, typedDirection);\n    }\n    provider.on(filter, listener);\n    tearDowns.push(provider.off.bind(provider, filter, listener));\n  });\n\n  return () => {\n    tearDowns.forEach((fn) => fn());\n  };\n};\n\nexport { fetchBalances, fetchAllowances, subscribeToTransfersAndApprovals };\n","import { useTranslation } from \"react-i18next\";\nimport { RiCloseLine } from \"react-icons/ri\";\nimport truncateEthAddress from \"truncate-eth-address\";\nimport Blockies from \"react-blockies\";\n\nimport Button from \"../Button/Button\";\nimport classNames from \"classnames\";\n\nexport type WalletButtonProps = {\n  /**\n   * Address of currenlty connected wallet, if any\n   */\n  address?: string | null;\n  /**\n   * Boolean to indicate if wallet is currently connecting. (Ignored if address\n   * is set)\n   */\n  isConnecting?: boolean;\n  /**\n   * Additional classes applied to container\n   */\n  className?: string;\n  /**\n   * Callback function for when connect button is clicked\n   */\n  onConnectWalletClicked: () => void;\n  /**\n   * Callback function for when disconnect button is clicked\n   */\n  onDisconnectWalletClicked: () => void;\n};\n\nexport const WalletButton = ({\n  address,\n  className,\n  isConnecting,\n  onConnectWalletClicked,\n  onDisconnectWalletClicked,\n}: WalletButtonProps) => {\n  const { t } = useTranslation([\"wallet\"]);\n  return (\n    <div className={className}>\n      {address ? (\n        <div\n          className={classNames(\n            \"flex flex-row items-center\",\n            \"px-2 py-1\",\n            \"rounded-sm\",\n            \"bg-gray-200 dark:bg-gray-800\"\n          )}\n        >\n          <Blockies\n            size={8}\n            scale={3}\n            seed={address}\n            className=\"-ml-1 rounded-sm mr-2\"\n            bgColor=\"black\"\n            color=\"#2b72ff\"\n          />\n          <span>{truncateEthAddress(address)}</span>\n          <button\n            className=\"ml-2\"\n            aria-label={t(\"wallet:disconnectWallet\")}\n            onClick={onDisconnectWalletClicked}\n          >\n            <RiCloseLine />\n          </button>\n        </div>\n      ) : (\n        <Button\n          intent=\"primary\"\n          loading={isConnecting}\n          onClick={onConnectWalletClicked}\n        >\n          {t(\"wallet:connectWallet\")}\n        </Button>\n      )}\n    </div>\n  );\n};\n\nexport default WalletButton;\n","import { AbstractConnector } from \"@web3-react/abstract-connector\";\nimport { InjectedConnector } from \"@web3-react/injected-connector\";\nimport { WalletConnectConnector } from \"@web3-react/walletconnect-connector\";\nimport metamaskLogo from \"../assets/wallet-provider-logos/metamask.svg\";\nimport walletconnectLogo from \"../assets/wallet-provider-logos/walletconnect.svg\";\n\nexport type WalletProvider = {\n  name: string;\n  logo: string;\n  getConnector: () => AbstractConnector;\n};\n\nconst SUPPORTED_WALLET_PROVIDERS: WalletProvider[] = [\n  {\n    name: \"MetaMask\",\n    logo: metamaskLogo,\n    getConnector: () =>\n      new InjectedConnector({\n        supportedChainIds: [\n          1, // Mainet\n          3, // Ropsten\n          4, // Rinkeby\n          5, // Goerli\n          42, // Kovan\n        ],\n      }),\n  },\n  {\n    name: \"WalletConnect\",\n    logo: walletconnectLogo,\n    getConnector: () =>\n      new WalletConnectConnector({\n        rpc: {\n          1: process.env.REACT_APP_RPC_URL_1 || \"\",\n          4: process.env.REACT_APP_RPC_URL_4 || \"\",\n        },\n      }),\n  },\n];\n\nexport default SUPPORTED_WALLET_PROVIDERS;\n\nexport { AbstractConnector };\n","export default __webpack_public_path__ + \"static/media/metamask.45038d58.svg\";","export default __webpack_public_path__ + \"static/media/walletconnect.dfa25e47.svg\";","import SUPPORTED_WALLET_PROVIDERS, {\n  WalletProvider,\n} from \"../../constants/supportedWalletProviders\";\nimport Button from \"../Button/Button\";\n\nexport type WalletProviderListProps = {\n  onProviderSelected: (provider: WalletProvider) => void;\n};\n\nconst WalletProviderList = ({\n  onProviderSelected,\n}: WalletProviderListProps) => {\n  return (\n    <div className=\"flex flex-col gap-2\">\n      {SUPPORTED_WALLET_PROVIDERS.map((provider) => (\n        <Button\n          key={provider.name}\n          variant=\"left-justified\"\n          intent=\"neutral\"\n          onClick={() => {\n            onProviderSelected(provider);\n          }}\n        >\n          <div className=\"flex gap-2 items-center pr-2\">\n            <img\n              src={provider.logo}\n              alt={`${provider.name} logo`}\n              className=\"w-12 h-12\"\n            />\n            <span className=\"flex-1\">{provider.name}</span>\n          </div>\n        </Button>\n      ))}\n    </div>\n  );\n};\n\nexport default WalletProviderList;\n","import { BigNumber, ethers } from \"ethers\";\nimport {\n  AsyncThunk,\n  createAction,\n  createAsyncThunk,\n  createSlice,\n  PayloadAction,\n} from \"@reduxjs/toolkit\";\nimport { fetchAllowances, fetchBalances } from \"./balancesApi\";\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { setWalletConnected } from \"../wallet/walletSlice\";\n\nexport interface BalancesState {\n  status: \"idle\" | \"fetching\" | \"failed\";\n  /** Timestamp of last successful fetch */\n  lastFetch: number | null;\n  /** An array of token addresses currently being fetched. If there are two\n   * fetches in flight, this array will contain the list of addresses in the\n   * largest request.\n   */\n  inFlightFetchTokens: string[] | null; // used to prevent duplicate fetches\n  /** Token balances */\n  values: {\n    [tokenAddress: string]: string | null; // null while fetching\n  };\n}\n\n// Initially empty.\nexport const initialState: BalancesState = {\n  status: \"idle\",\n  lastFetch: null,\n  inFlightFetchTokens: null,\n  values: {},\n};\n\nconst getSetInFlightRequestTokensAction = (type: \"balances\" | \"allowances\") => {\n  return createAction<string[]>(`${type}/setInFlightRequestTokens`);\n};\n\nconst getThunk: (type: \"balances\" | \"allowances\") => AsyncThunk<\n  { address: string; amount: string }[],\n  {\n    provider: ethers.providers.Web3Provider;\n  },\n  {}\n> = (type: \"balances\" | \"allowances\") => {\n  const methods = {\n    balances: fetchBalances,\n    allowances: fetchAllowances,\n  };\n  return createAsyncThunk<\n    { address: string; amount: string }[],\n    {\n      provider: ethers.providers.Web3Provider;\n    },\n    {\n      // Optional fields for defining thunkApi field types\n      dispatch: AppDispatch;\n      state: RootState;\n    }\n  >(\n    `${type}/requestForActiveTokens`,\n    async (params, { getState, dispatch }) => {\n      try {\n        const state = getState();\n        const activeTokensAddresses = state.metadata.tokens.active;\n        const { chainId, address } = state.wallet;\n        dispatch(\n          getSetInFlightRequestTokensAction(type)(activeTokensAddresses)\n        );\n        const amounts = await methods[type]({\n          ...params,\n          chainId: chainId!,\n          walletAddress: address!,\n          tokenAddresses: activeTokensAddresses,\n        });\n        return activeTokensAddresses.map((address, i) => ({\n          address,\n          amount: amounts[i],\n        }));\n      } catch (e) {\n        console.error(`Error fetching ${type}: ` + e.message);\n        // TODO: error handling\n        return [];\n      }\n    },\n    {\n      // Logic to prevent fetching again if we're already fetching the same or more tokens.\n      condition: (params, { getState }) => {\n        const sliceState = getState()[type];\n        // If we're not fetching, definitely continue\n        if (sliceState.status !== \"fetching\") return true;\n        if (sliceState.inFlightFetchTokens) {\n          const tokensToFetch = getState().metadata.tokens.active;\n          // only fetch if new list is larger.\n          return tokensToFetch.length > sliceState.inFlightFetchTokens.length;\n        }\n      },\n    }\n  );\n};\n\nconst getSlice = (\n  type: \"balances\" | \"allowances\",\n  asyncThunk: ReturnType<typeof getThunk>\n) => {\n  return createSlice({\n    name: type,\n    initialState,\n    reducers: {\n      incrementBy: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        const currentAmount = BigNumber.from(\n          state.values[action.payload.tokenAddress.toLowerCase()] || 0\n        );\n        state.values[action.payload.tokenAddress.toLowerCase()] = currentAmount\n          .add(action.payload.amount)\n          .toString();\n      },\n      decrementBy: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        const currentAmount = BigNumber.from(\n          state.values[action.payload.tokenAddress.toLowerCase()] || 0\n        );\n        let newAmount = currentAmount.sub(action.payload.amount);\n        if (newAmount.lt(\"0\")) newAmount = BigNumber.from(\"0\");\n        state.values[action.payload.tokenAddress.toLowerCase()] =\n          newAmount.toString();\n      },\n      set: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        state.values[action.payload.tokenAddress.toLowerCase()] =\n          action.payload.amount;\n      },\n    },\n    extraReducers: (builder) => {\n      builder\n        // Reset to initial state if a new account is connected.\n        .addCase(setWalletConnected, () => initialState)\n\n        // Handle requesting balances\n        .addCase(asyncThunk.pending, (state) => {\n          state.status = \"fetching\";\n        })\n        .addCase(getSetInFlightRequestTokensAction(type), (state, action) => {\n          state.inFlightFetchTokens = action.payload;\n        })\n        .addCase(asyncThunk.fulfilled, (state, action) => {\n          state.lastFetch = Date.now();\n          const tokenBalances = action.payload;\n\n          tokenBalances?.forEach(({ address, amount }) => {\n            state.values[address] = amount;\n          });\n\n          // Only clear fetching status if this request contained the largest\n          // list of tokens (which will be stored in inFlightFetchTokens)\n          if (\n            state.inFlightFetchTokens &&\n            tokenBalances.every(\n              (result, i) => state.inFlightFetchTokens![i] === result.address\n            )\n          ) {\n            state.inFlightFetchTokens = null;\n            state.status = \"idle\";\n          }\n        })\n        .addCase(asyncThunk.rejected, (state, action) => {\n          state.status = \"failed\";\n        });\n    },\n  });\n};\n\nexport const selectBalances = (state: RootState) => state.balances;\nexport const selectAllowances = (state: RootState) => state.allowances;\n\nexport const requestActiveTokenBalances = getThunk(\"balances\");\nexport const requestActiveTokenAllowances = getThunk(\"allowances\");\n\nexport const balancesSlice = getSlice(\"balances\", requestActiveTokenBalances);\nexport const allowancesSlice = getSlice(\n  \"allowances\",\n  requestActiveTokenAllowances\n);\n\nexport const {\n  incrementBy: incrementBalanceBy,\n  decrementBy: decrementBalanceBy,\n  set: setBalance,\n} = balancesSlice.actions;\nexport const {\n  incrementBy: incrementAllowanceBy,\n  decrementBy: decreementAllowanceBy,\n  set: setAllowance,\n} = allowancesSlice.actions;\n\nexport const balancesActions = balancesSlice.actions;\nexport const allowancesActions = allowancesSlice.actions;\n\nexport const balancesReducer = balancesSlice.reducer;\nexport const allowancesReducer = allowancesSlice.reducer;\n","import SUPPORTED_WALLET_PROVIDERS, {\n  WalletProvider,\n} from \"../../constants/supportedWalletProviders\";\n\nconst LAST_ACCOUNT_LOCAL_STORAGE_KEY = `airswap/lastConnectedAccount`;\n\nconst saveLastAccount = (address: string, provider: WalletProvider) => {\n  localStorage.setItem(\n    LAST_ACCOUNT_LOCAL_STORAGE_KEY,\n    `${provider.name}/${address}`\n  );\n};\n\nconst clearLastAccount = () => {\n  localStorage.setItem(LAST_ACCOUNT_LOCAL_STORAGE_KEY, \"\");\n};\n\nconst loadLastAccount = () => {\n  try {\n    const storedString = localStorage.getItem(LAST_ACCOUNT_LOCAL_STORAGE_KEY);\n    if (!storedString) throw new Error(\"No connected accounts saved\");\n    const [providerName, address] = storedString.split(\"/\");\n    const provider = SUPPORTED_WALLET_PROVIDERS.find(\n      (p) => p.name === providerName\n    );\n    if (!provider) throw new Error(`Could not find provider: ${providerName}`);\n    return {\n      provider,\n      address,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n\nexport { loadLastAccount, saveLastAccount, clearLastAccount };\n","import { Light } from \"@airswap/protocols\";\nimport { useMatomo } from \"@datapunt/matomo-tracker-react\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport { WalletConnectConnector } from \"@web3-react/walletconnect-connector\";\nimport { useEffect, useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\nimport WalletButton from \"../../components/WalletButton/WalletButton\";\nimport WalletProviderList from \"../../components/WalletProviderList/WalletProviderList\";\nimport Modal from \"react-modal\";\nimport {\n  AbstractConnector,\n  WalletProvider,\n} from \"../../constants/supportedWalletProviders\";\nimport { subscribeToTransfersAndApprovals } from \"../balances/balancesApi\";\nimport {\n  decrementBalanceBy,\n  incrementBalanceBy,\n  requestActiveTokenAllowances,\n  requestActiveTokenBalances,\n  selectBalances,\n  setAllowance,\n} from \"../balances/balancesSlice\";\nimport { fetchAllTokens, selectActiveTokens } from \"../metadata/metadataSlice\";\nimport {\n  clearLastAccount,\n  loadLastAccount,\n  saveLastAccount,\n} from \"./walletAPI\";\nimport { setWalletConnected, setWalletDisconnected } from \"./walletSlice\";\n\nexport const Wallet = () => {\n  const {\n    chainId,\n    account,\n    activate,\n    deactivate,\n    active,\n    library,\n  } = useWeb3React<Web3Provider>();\n\n  // Redux\n  const dispatch = useAppDispatch();\n  const activeTokens = useAppSelector(selectActiveTokens);\n  const balances = useAppSelector(selectBalances);\n\n  // Analytics\n  const { trackPageView } = useMatomo();\n\n  // i18n\n  const { t } = useTranslation([\"common\", \"wallet\"]);\n\n  // Local component state\n  const [showConnectorList, setShowConnectorList] = useState<boolean>(false);\n  const [isActivating, setIsActivating] = useState<boolean>(false);\n  const [connector, setConnector] = useState<AbstractConnector>();\n  const [provider, setProvider] = useState<WalletProvider>();\n\n  // Auto-activate if user has connected before on (first render)\n  useEffect(() => {\n    trackPageView({ documentTitle: \"Swap Page\", href: \"https://airswap.io\" });\n    const lastConnectedAccount = loadLastAccount();\n    if (lastConnectedAccount) {\n      setIsActivating(true);\n      const connector = lastConnectedAccount.provider.getConnector();\n      setConnector(connector);\n      setProvider(lastConnectedAccount.provider);\n      activate(connector).finally(() => setIsActivating(false));\n    }\n  }, [activate, trackPageView]);\n\n  // Trigger request for balances and allowances once account is connected\n  useEffect(() => {\n    if (active && account && chainId && library && connector && provider) {\n      // Dispatch a general action to indicate wallet has changed\n      dispatch(\n        setWalletConnected({\n          chainId,\n          address: account,\n        })\n      );\n      saveLastAccount(account, provider);\n      dispatch(fetchAllTokens());\n      dispatch(\n        requestActiveTokenAllowances({\n          provider: library,\n        })\n      );\n      dispatch(\n        requestActiveTokenBalances({\n          provider: library,\n        })\n      );\n    } else {\n      dispatch(setWalletDisconnected());\n    }\n  }, [active, account, chainId, dispatch, library, connector, provider]);\n\n  // Subscribe to changes in balance\n  useEffect(() => {\n    if (\n      !library ||\n      !account ||\n      !connector ||\n      chainId === undefined ||\n      !activeTokens.length ||\n      balances.lastFetch === null ||\n      balances.status !== \"idle\"\n    )\n      return;\n\n    let teardownTransferListener: () => void;\n    if (activeTokens.length) {\n      teardownTransferListener = subscribeToTransfersAndApprovals({\n        activeTokenAddresses: activeTokens.map((t) => t.address),\n        provider: library,\n        walletAddress: account,\n        spenderAddress: Light.getAddress(),\n        onBalanceChange: (tokenAddress, amount, direction) => {\n          const actionCreator =\n            direction === \"in\" ? incrementBalanceBy : decrementBalanceBy;\n          dispatch(\n            actionCreator({\n              tokenAddress,\n              amount: amount.toString(),\n            })\n          );\n        },\n        onApproval: (tokenAddress, amount) => {\n          dispatch(\n            setAllowance({\n              tokenAddress,\n              amount: amount.toString(),\n            })\n          );\n        },\n      });\n    }\n    return () => {\n      if (teardownTransferListener) {\n        teardownTransferListener();\n      }\n    };\n  }, [\n    activeTokens,\n    account,\n    library,\n    connector,\n    dispatch,\n    chainId,\n    balances.lastFetch,\n    balances.status,\n  ]);\n\n  return (\n    <div>\n      <div>\n        {t(\"common:chainId\")}: {chainId}\n      </div>\n\n      <Modal\n        isOpen={showConnectorList}\n        onRequestClose={() => setShowConnectorList(false)}\n        overlayClassName=\"absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-50 p-10\"\n        className=\"w-64 p-4 rounded-sm bg-white dark:bg-gray-800 shadow-lg\"\n      >\n        <WalletProviderList\n          onProviderSelected={(provider) => {\n            setProvider(provider);\n            const connector = provider.getConnector();\n            setConnector(connector);\n            setShowConnectorList(false);\n            setIsActivating(true);\n            activate(connector).finally(() => setIsActivating(false));\n          }}\n        />\n      </Modal>\n      <WalletButton\n        address={account}\n        onConnectWalletClicked={() => {\n          setShowConnectorList(true);\n        }}\n        onDisconnectWalletClicked={() => {\n          clearLastAccount();\n          deactivate();\n          if (connector instanceof WalletConnectConnector) {\n            connector.close();\n          }\n        }}\n        isConnecting={isActivating}\n      />\n    </div>\n  );\n};\n","import { useEffect } from \"react\";\nimport { getEtherscanURL } from \"@airswap/utils\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport { useAppSelector, useAppDispatch } from \"../../app/hooks\";\nimport {\n  selectTransactions,\n  setTransactions,\n  TransactionsState,\n} from \"./transactionsSlice\";\nimport { revertTransaction, mineTransaction } from \"./transactionActions\";\nimport { getTransactionsLocalStorageKey } from \"../metadata/metadataApi\";\n\nexport function Transactions() {\n  const transactions = useAppSelector(selectTransactions);\n  const dispatch = useAppDispatch();\n  const { active, chainId, library, account } = useWeb3React<Web3Provider>();\n\n  useEffect(() => {\n    // Create a flag we can set to handle wallet changing between async operations\n    let walletHasChanged = false;\n\n    // get transaction state from local storage and update the transactions\n    if (chainId && account && library) {\n      const transactionsLocalStorage: TransactionsState = JSON.parse(\n        localStorage.getItem(\n          getTransactionsLocalStorageKey(account!, chainId!)\n        )!\n      ) || { all: [] };\n\n      dispatch(setTransactions(transactionsLocalStorage));\n\n      // check from all responses if one is pending... if pending, call getTransaction\n      // to see if it was a success/failure/pending. update accordingly. if pending: wait()\n      // and poll at a sensible interval.\n      transactionsLocalStorage.all.forEach(async (tx) => {\n        if (tx.status === \"processing\") {\n          let receipt = await library.getTransactionReceipt(tx.hash);\n          if (receipt !== null) {\n            if (walletHasChanged) return;\n            const status = receipt.status;\n            if (status === 1) dispatch(mineTransaction(tx.hash));\n            // success\n            else if (status === 0)\n              dispatch(\n                revertTransaction({\n                  hash: tx.hash,\n                  reason: \"Reverted\",\n                })\n              ); // reverted\n            return;\n          } else {\n            // Receipt was null, so the transaction is incomplete\n            // Try to get a reference to the transaction in the mem pool - this\n            // can sometimes also return null (e.g. gas price too low or tx only\n            // recently sent) depending on backend.\n            const transaction = await library.getTransaction(tx.hash);\n            if (transaction) {\n              try {\n                await transaction.wait(1);\n                if (!walletHasChanged) dispatch(mineTransaction(tx.hash)); // success\n              } catch (err) {\n                console.error(err);\n                if (!walletHasChanged)\n                  dispatch(\n                    revertTransaction({\n                      hash: tx.hash,\n                      reason: \"Reverted\",\n                    })\n                  );\n              }\n              return;\n            } else {\n              // if transaction === null, we poll at intervals\n              // assume failed after 30 mins\n              const assumedFailureTime = Date.now() + 30 * 60 * 1000;\n              while (receipt === null && Date.now() <= assumedFailureTime) {\n                // wait 30 seconds\n                await new Promise((res) => setTimeout(res, 30000));\n                receipt = await library!.getTransactionReceipt(tx.hash);\n              }\n              if (!receipt || receipt.status === 0) {\n                if (!walletHasChanged)\n                  dispatch(\n                    revertTransaction({\n                      hash: tx.hash,\n                      reason: \"Reverted\",\n                    })\n                  );\n              } else {\n                if (!walletHasChanged) dispatch(mineTransaction(tx.hash)); // success\n              }\n            }\n          }\n        }\n      });\n    }\n    return () => {\n      // Library & dispatch won't change, so when we tear down it's because\n      // the wallet has changed. The useEffect will run after this and set up\n      // everything for the new wallet.\n      walletHasChanged = true;\n    };\n  }, [chainId, dispatch, library, account]);\n\n  if (!active || !chainId) return null;\n\n  const icons = {\n    succeeded: \"✅\",\n    reverted: \"🚫\",\n    processing: \"⏳\",\n  };\n\n  return (\n    <div>\n      {transactions.map((submittedOrder) => (\n        <div key={submittedOrder.hash}>\n          {icons[submittedOrder.status]}:\n          <a\n            target=\"_blank\"\n            rel=\"noreferrer\"\n            href={`${getEtherscanURL(`${chainId}`, submittedOrder.hash!)}`}\n          >\n            {submittedOrder.hash}\n          </a>\n        </div>\n      ))}\n    </div>\n  );\n}\n","import { Fragment, useState } from \"react\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\nimport {\n  requestActiveTokenAllowances,\n  requestActiveTokenBalances,\n  selectAllowances,\n  selectBalances,\n} from \"./balancesSlice\";\nimport classes from \"./Balances.module.css\";\nimport { formatUnits } from \"@ethersproject/units\";\nimport { addActiveToken, selectActiveTokens } from \"../metadata/metadataSlice\";\nimport { useTranslation } from \"react-i18next\";\nimport Button from \"../../components/Button/Button\";\n\nconst Balances = () => {\n  const { active, library } = useWeb3React();\n  const activeTokens = useAppSelector(selectActiveTokens);\n  const dispatch = useAppDispatch();\n  const balances = useAppSelector(selectBalances);\n  const allowances = useAppSelector(selectAllowances);\n\n  const [addTokenField, setAddTokenField] = useState<string>(\"\");\n\n  const { t } = useTranslation([\"balances\", \"common\"]);\n\n  return active ? (\n    <div>\n      <hr />\n      <h4>{t(\"balances:tokenBalances\")}</h4>\n      <div className={classes.balancesGrid}>\n        <span className={classes.bold}>{t(\"balances:symbol\")}</span>\n        <span className={classes.bold}>{t(\"balances:balance\")}</span>\n        <span className={classes.bold}>{t(\"balances:allowance\")}</span>\n        {activeTokens.map((tokenInfo) => {\n          const tokenBalance = balances.values[tokenInfo.address];\n          const tokenAllowance = allowances.values[tokenInfo.address];\n          return (\n            <Fragment key={`${tokenInfo.address}-balance`}>\n              <span>{tokenInfo.symbol}:</span>\n              <span>\n                {tokenBalance != null\n                  ? formatUnits(tokenBalance, tokenInfo.decimals)\n                  : t(\"common:fetching\")}\n              </span>\n              <span>\n                {tokenAllowance != null\n                  ? formatUnits(tokenAllowance, tokenInfo.decimals)\n                  : t(\"common:fetching\")}\n              </span>\n            </Fragment>\n          );\n        })}\n      </div>\n      <input\n        type=\"text\"\n        value={addTokenField}\n        onChange={(e) => {\n          setAddTokenField(e.target.value);\n        }}\n      />\n      <Button\n        type=\"button\"\n        onClick={() => {\n          dispatch(addActiveToken(addTokenField));\n          dispatch(requestActiveTokenBalances({ provider: library }));\n          dispatch(requestActiveTokenAllowances({ provider: library }));\n          setAddTokenField(\"\");\n        }}\n      >\n        {t(\"balances:addToTokenSet\")}\n      </Button>\n      {/* <button type=\"button\" onClick={fetchBalancesAndAllowances}>\n        Update balances\n      </button> */}\n      <hr />\n    </div>\n  ) : null;\n};\n\nexport default Balances;\n","import i18n from \"i18next\";\nimport { initReactI18next } from \"react-i18next\";\n\nimport HttpBackend from \"i18next-http-backend\";\nimport LanguageDetector from \"i18next-browser-languagedetector\";\n\ni18n\n  // load translation using http -> see /public/locales\n  .use(HttpBackend)\n  // detect user language\n  // learn more: https://github.com/i18next/i18next-browser-languageDetector\n  .use(LanguageDetector)\n  // pass the i18n instance to react-i18next.\n  .use(initReactI18next)\n  // init i18next\n  // for all options read: https://www.i18next.com/overview/configuration-options\n  .init({\n    fallbackLng: \"en\",\n    ns: \"common\",\n    load: \"languageOnly\",\n    debug: process.env.NODE_ENV !== \"production\",\n    interpolation: {\n      escapeValue: false, // not needed for react as it escapes by default\n    },\n    react: {\n      useSuspense: true,\n    },\n    backend: {\n      loadPath: \"/locales/{{lng}}/{{ns}}.json\",\n    },\n  });\n\nexport default i18n;\n","import classNames from \"classnames\";\nimport { useEffect, useState } from \"react\";\nimport { RiSunLine, RiMoonLine } from \"react-icons/ri\";\n\nconst THEME_LOCAL_STORAGE_KEY = \"airswap/theme\";\n\nfunction enableDarkMode(): void {\n  document.documentElement.classList.add(\"dark\");\n  localStorage[THEME_LOCAL_STORAGE_KEY] = \"dark\";\n}\n\nfunction disableDarkMode(): void {\n  document.documentElement.classList.remove(\"dark\");\n  localStorage[THEME_LOCAL_STORAGE_KEY] = \"light\";\n}\n\n// On page load or when changing themes, best to add inline in `head` to avoid FOUC\nif (\n  localStorage[THEME_LOCAL_STORAGE_KEY] === \"dark\" ||\n  (!(\"theme\" in localStorage) &&\n    window.matchMedia(\"(prefers-color-scheme: dark)\").matches)\n) {\n  enableDarkMode();\n} else {\n  disableDarkMode();\n}\n\ntype DarkModeProps = {\n  className?: string;\n};\n\n// Whenever the user explicitly chooses to respect the OS preference\n// localStorage.removeItem('theme')\nconst DarkModeSwitch = ({ className }: DarkModeProps): JSX.Element => {\n  const [darkModeEnabled, setDarkModeEnabled] = useState<boolean>();\n\n  useEffect(() => {\n    setDarkModeEnabled(localStorage[THEME_LOCAL_STORAGE_KEY] === \"dark\");\n  }, []);\n\n  return (\n    <button\n      onClick={() => {\n        if (darkModeEnabled) disableDarkMode();\n        else enableDarkMode();\n        setDarkModeEnabled((toggle) => !toggle);\n      }}\n      className={classNames(\"px-4 py-2 text-2xl\", className)}\n    >\n      {darkModeEnabled ? (\n        <RiMoonLine className=\"-m-2\" />\n      ) : (\n        <RiSunLine className=\"-m-2\" />\n      )}\n    </button>\n  );\n};\n\nexport default DarkModeSwitch;\n","import { Suspense } from \"react\";\nimport { Web3ReactProvider } from \"@web3-react/core\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { Orders } from \"./features/orders/Orders\";\nimport { Wallet } from \"./features/wallet/Wallet\";\nimport { Transactions } from \"./features/transactions/Transactions\";\nimport Balances from \"./features/balances/Balances\";\nimport \"./i18n/i18n\";\nimport DarkModeSwitch from \"./components/DarkModeSwitch/DarkModeSwitch\";\n\nfunction getLibrary(provider: any): Web3Provider {\n  const library = new Web3Provider(provider);\n  library.pollingInterval = 12000;\n  return library;\n}\n\nfunction App() {\n  return (\n    <Web3ReactProvider getLibrary={getLibrary}>\n      {/* Suspense needed here for loading i18n resources */}\n      <Suspense fallback={\"Loading...\"}>\n        <div className=\"flex flex-col items-center\">\n          <Wallet />\n          <Orders />\n          <Transactions />\n          ☠️ Use at your own risk\n          <Balances />\n          <DarkModeSwitch className=\"m-4\" />\n        </div>\n      </Suspense>\n    </Web3ReactProvider>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from \"@reduxjs/toolkit\";\nimport ordersReducer from \"../features/orders/ordersSlice\";\nimport walletReducer from \"../features/wallet/walletSlice\";\nimport metadataReducer from \"../features/metadata/metadataSlice\";\nimport transactionsReducer from \"../features/transactions/transactionsSlice\";\nimport {\n  balancesReducer,\n  allowancesReducer,\n} from \"../features/balances/balancesSlice\";\nimport { subscribeToSavedTokenChangesForLocalStoragePersisting } from \"../features/metadata/metadataSubscriber\";\n\nexport const store = configureStore({\n  reducer: {\n    allowances: allowancesReducer,\n    transactions: transactionsReducer,\n    balances: balancesReducer,\n    metadata: metadataReducer,\n    orders: ordersReducer,\n    wallet: walletReducer,\n  },\n});\n\nsubscribeToSavedTokenChangesForLocalStoragePersisting();\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","import { store } from \"../../app/store\";\nimport {\n  getActiveTokensLocalStorageKey,\n  getTransactionsLocalStorageKey,\n} from \"./metadataApi\";\nimport {\n  SubmittedTransaction,\n  TransactionsState,\n} from \"../transactions/transactionsSlice\";\n\nexport const subscribeToSavedTokenChangesForLocalStoragePersisting = () => {\n  const activeTokensCache: {\n    [address: string]: {\n      [chainId: number]: string[];\n    };\n  } = {};\n  const transactionCache: {\n    [address: string]: {\n      [chainId: number]: SubmittedTransaction[];\n    };\n  } = {};\n\n  let currentTransaction: TransactionsState;\n\n  store.subscribe(() => {\n    const { wallet, metadata, transactions } = store.getState();\n    if (!wallet.connected) return;\n\n    let previousTransaction = currentTransaction;\n    currentTransaction = transactions;\n\n    if (previousTransaction !== currentTransaction) {\n      // handles change in transactions and persists all transactions to localStorage\n      // TODO: don't save all transactions (e.g. max 10 transactions)\n      const txs: TransactionsState = JSON.parse(\n        localStorage.getItem(\n          getTransactionsLocalStorageKey(wallet.address!, wallet.chainId!)\n        )!\n      ) || { all: [] };\n\n      if (transactionCache[wallet.address!] === undefined) {\n        transactionCache[wallet.address!] = {};\n        transactionCache[wallet.address!][wallet.chainId!] = txs.all;\n      }\n      if (\n        transactions.all.length &&\n        transactionCache[wallet.address!][wallet.chainId!] !== transactions.all\n      ) {\n        transactionCache[wallet.address!][wallet.chainId!] = transactions.all;\n        localStorage.setItem(\n          getTransactionsLocalStorageKey(wallet.address!, wallet.chainId!),\n          JSON.stringify(transactions)\n        );\n      }\n    }\n\n    if (!activeTokensCache[wallet.address!]) {\n      activeTokensCache[wallet.address!] = {};\n    }\n    const cachedTokensForActiveWallet =\n      activeTokensCache[wallet.address!][wallet.chainId!];\n    if (\n      metadata.tokens.active.length &&\n      cachedTokensForActiveWallet !== metadata.tokens.active\n    ) {\n      // active tokens have changed, persist to local storage.\n      activeTokensCache[wallet.address!][wallet.chainId!] =\n        metadata.tokens.active;\n      localStorage.setItem(\n        getActiveTokensLocalStorageKey(wallet.address!, wallet.chainId!),\n        metadata.tokens.active.join(\",\")\n      );\n    }\n  });\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport { store } from \"./app/store\";\nimport { Provider } from \"react-redux\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { MatomoProvider, createInstance } from \"@datapunt/matomo-tracker-react\";\nimport Modal from \"react-modal\";\n\nconst instance = createInstance({\n  urlBase: \"https://airswap.matomo.cloud/\",\n  siteId: 1,\n  // userId: 'UID76903202', // optional, default value: `undefined`.\n  // trackerUrl: 'https://LINK.TO.DOMAIN/tracking.php', // optional, default value: `${urlBase}matomo.php`\n  srcUrl: \"https://cdn.matomo.cloud/airswap.matomo.cloud/matomo.js\", // optional, default value: `${urlBase}matomo.js`\n  disabled: false, // optional, false by default. Makes all tracking calls no-ops if set to true.\n  heartBeat: {\n    // optional, enabled by default\n    active: true, // optional, default value: true\n    seconds: 10, // optional, default value: `15\n  },\n  linkTracking: false, // optional, default value: true\n  configurations: {\n    // optional, default value: {}\n    // any valid matomo configuration, all below are optional\n    disableCookies: true,\n    setSecureCookie: true,\n    setRequestMethod: \"POST\",\n  },\n});\n\nModal.setAppElement(\"#root\");\n\nReactDOM.render(\n  <React.StrictMode>\n    <MatomoProvider value={instance}>\n      <Provider store={store}>\n        <App />\n      </Provider>\n    </MatomoProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}